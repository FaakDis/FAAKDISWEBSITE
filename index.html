<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <title>FΔΔKD!S WΞBS!TΞ</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.6.1/web3.min.js"></script> <!-- Include Web3.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        body { 
            background: #000;
            background-size: cover; /* Adjust size as needed (50% is an example) */
            color: #00ffd5;
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 140;
            flex-direction: column;
            cursor: url('/cursor/faakdis.cur'), auto;
        } 
        .cta-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 5px;
        }
        .cta-buttons a, .cta-buttons button {
            text-decoration: none;
            color: #00ffd5;
            background-color: rgba(0, 0, 0, 0.1);
            border: 0px solid #00ffd5;
            border-radius: 7px;
            box-shadow: 0 0 2px #00ffd5;
            padding: 6px 14px;
            margin: 5px;
            font-size: 9px;
            transition: background-color 0.3s, box-shadow 0.3s;
            cursor: url('/cursor/faakdis.cur'), auto;
        }
        .cta-buttons a:hover, .cta-buttons button:hover {
            background-color: #00A085;
            box-shadow: 0 0 1px #00ffd5;
        }
        .pof-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background-color: rgba(0, 0, 0, 0.1);
    border: 0px solid #00ffd5; /* Ice blue border */
    border-radius: 8px;
    padding: 8px;
    box-shadow: 0 0 2px #00ffd5;
    width: 95%; /* Limit the width for a compact look */
    max-width: 420px; /* Ideal for mobile screens */
    margin: 10px auto;
    position: relative;
        }
        .pof-dashboard {
            text-align: center;
            padding: 10px;
            border: 0px solid #00ffd5;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 2px #00ffd5;
            margin-bottom: 5px;
        }
        .canvas-container {
            position: relative;
            border: 0px solid #00ffd5;
            border-radius: 8px;
             box-shadow: 0 0 2px #00ffd5;
            width: 100%;
            max-width: 400px;
            height: 200px;
            margin: 5px 0;
            overflow: hidden;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
            background-color: transparent;
        }
        .button {
            padding: 6px 12px;
            background-color: rgba(0, 0, 0, 0.1);
            color: #00ffd5;
            border: none;
            border-radius: 5px;
            box-shadow: 0 0 2px #00ffd5;
            cursor:url('/cursor/faakdis.cur'), auto;
            font-size: 10px;
            margin: 3px;
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        .button:hover {
            background-color: #00A085;
            box-shadow: 0 0 1px #00ffd5;
        }
       .mining-stats-container {
    border: 0px solid #00ffd5; /* Ice blue border for frame */
    border-radius: 8px;
    box-shadow: 0 0 2px #00ffd5; /* Subtle glow effect */
    padding: 10px;
    margin: 10px 0;
    background-color: rgba(0, 0, 0, 0.2); /* Transparent background inside the frame */
    width: calc(100% - 20px); /* Keep it compact */
    max-width: 380px; /* Ensure it stays compact for mobile */
}

        
        .mining-stats {
            text-align: center;
            margin-top: 10px;
        }
        .mining-stats div {
            margin: 3px 0;
            font-size: 12px;
        }
        .level-bar {
            position: absolute;
            bottom: 0px;
            left: 10px;
            width: calc(100% - 20px);
            height: 5px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 0px solid #00ffd5;
            border-radius: 8px;
            box-shadow: 0 0 2px #00ffd5;
            display: flex;
            align-items: center;
            padding: 2px;
        }
        .level-fill {
            height: 80%;
            background-color: #00ff00;
            border-radius: 6px;
            transition: width 0.3s;
        }
        .token-balance {
            margin-top: 10px;
            font-size: 12px;
        }
        .status-message {
            margin-top: 10px;
            font-size: 10px;
            color: #00ffd5;
        }
        .star-rating {
          font-size: 10px;
          color: #FFD700;  /* Gold color for stars */
          margin-bottom: 10px;
        }
        .star-rating .star {
        display: inline-block;
        transition: transform 1s;
        }
       .star-rating .star:hover {
       transform: scale(2);
        }
        
        /* Container for the toggle */
.ipfs-toggle {
  display: flex;
  align-items: center; /* Align items vertically */
  justify-content: center; /* Center horizontally */
  background-color: rgba(0, 0, 0, 0.0); /* Semi-transparent black background */
  padding: 10px 20px; /* Spacing inside the container */
  border: 0px solid #000; /* Neon ice blue border */
  border-radius: 10px; /* Rounded corners */
  box-shadow: 0 0 0px #000; /* Neon glow */
  cursor: url('/cursor/faakdis.cur'), auto;
  transition: all 0.3s ease; /* Smooth hover effects */
}

/* Input toggle (checkbox) */
.ipfs-toggle input[type="checkbox"] {
  appearance: none; /* Remove default checkbox styling */
  width: 5px;
  height: 5px;
  border: 2px solid #00ffd5; /* Neon border */
  border-radius: 5px; /* Rounded toggle corners */
  background-color: transparent; /* Transparent background */
  cursor: url('/cursor/faakdis.cur'), auto;
  position: relative; /* For inner styling */
  outline: none; /* Remove default focus outline */
  box-shadow: 0 0 0px #00ffd5; /* Subtle glow */
  transition: all 0.3s ease; /* Smooth animations */
}

/* Checked state for the checkbox */
.ipfs-toggle input[type="checkbox"]:checked {
  background-color: #00ffd5; /* Neon blue fill when checked */
  box-shadow: 0 0 1px #00ffd5; /* Glow intensifies */
  cursor: url('/cursor/faakdis.cur'), auto;
}



/* Hover effect for the container */
.ipfs-toggle:hover {
  box-shadow: 0 0 0px #00ffd5; /* Brighter glow */
  transform: scale(1.02); /* Slight enlargement */
  cursor: url('/cursor/faakdis.cur'), auto;
}

/* Main viewer styling */
#ipfsImageViewer {
    max-width: 90%;
    width: calc(100% - 20px); /* Ensure it stays within parent container */
    height: auto; /* Adapts to content */
    margin: 10px auto; /* Centered within parent */
    padding: 10px;
    background-color: rgba(0, 0, 0, 0.1);
    border-radius: 10px;
    box-shadow: 0 0 2px #00ffd5;
    position: relative;
    overflow: hidden; /* Prevents overflow of content */
    cursor: url('/cursor/faakdis.cur'), auto;
}

/* Horizontal sliding container for images (one image at a time) */
.gallery-container {
    display: flex;
    transition: transform 0.3s ease;
    width: 100%;
    flex-wrap: nowrap; /* Prevents wrapping */
    justify-content: flex-start; /* Align images to the start */
    overflow-x: auto; /* Allows horizontal scrolling if necessary */
    overflow-y: hidden; /* No vertical overflow */
    
    cursor: url('/cursor/faakdis.cur'), auto;
}

/* Individual image box styling */
.image-box {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 0 2px #00ffd5;
    margin: 10px;
    flex-shrink: 0; /* Prevents shrinking in flex layout */
    cursor: url('/cursor/faakdis.cur'), auto;
}

/* Futuristic Scrollbar Styling */
::-webkit-scrollbar {
    width: 10px; /* Width of the scrollbar */
    height: 10px; /* Height of the horizontal scrollbar */
}

::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2); /* Dark track for the scrollbar */
    border-radius: 10px; /* Rounded edges */
    box-shadow: inset 0 0 2px rgba(0, 255, 213, 0.3); /* Subtle inner glow */
}

::-webkit-scrollbar-thumb {
    background: linear-gradient(45deg, #00ffd5, #00A085); /* Futuristic gradient */
    border-radius: 10px; /* Rounded thumb for smoothness */
    box-shadow: 0 0 2px #00ffd5, 0 0 2px #00A085; /* Outer glow effect */
    border: 0px solid rgba(0, 0, 0, 0.4); /* Adds a border for depth */
}

::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(45deg, #00A085, #00ffd5); /* Inverse gradient on hover */
    box-shadow: 0 0 2px #00ffd5, 0 0 5px #00A085; /* Enhanced glow on hover */
}

::-webkit-scrollbar-corner {
    background: rgba(0, 0, 0, 0.2); /* Matching background for corner space */
}

/* Image styling */
.image-box img {
    max-width: 100%;
    max-height: 100%; /* Keeps the image within bounds */
    object-fit: contain; /* Ensures image does not stretch */
    border-radius: 5px;
    margin-bottom: 10px;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    transition: transform 0.3s ease;
}

/* Image hover effect */
.image-box img:hover {
    transform: scale(1.05);
    box-shadow: 0 0 10px #00ffd5;
}

/* Button styling */
.button {
    padding: 10px 20px;
    background-color: rgba(0, 0, 0, 0.5);
    color: #00ffd5;
    border: none;
    border-radius: 8px;
    margin: 5px;
    cursor: pointer;
    font-size: 12px;
    text-align: center;
    transition: background-color 0.3s, transform 0.3s;
    
}

.button:hover {
    background-color: #000;
    transform: scale(1.1);
}

/* Specific button variations */
.burn-btn { background-color: #000; }
.burn-btn:hover { background-color: #000; }

.mint-btn { background-color: #000; }
.mint-btn:hover { background-color: #000; }

.share-btn { background-color: #000; }
.share-btn:hover { background-color: #000; }

.keep-btn { background-color: #000; }
.keep-btn:hover { background-color: #000; }

/* Mobile adjustments */
@media (max-width: 420px) {
    #ipfsImageViewer {
        padding: 5px;
    }

    .image-box {
        margin: 5px;
        padding: 5px;
    }

    .button {
        padding: 8px 16px;
        font-size: 10px;
    }
}

.container {
    width: 100%;
    max-width: 355px;
    margin: 0;
    padding: 20px;
    border: 0 solid #00ffd5; /* Ice blue border */
    border-radius: 10px;
    box-shadow: 0 0 2px #00ffd5; /* Soft glow effect */
    cursor: url('/cursor/faakdis.cur'), auto; /* Custom cursor */
}

h1 {
    font-size: 12px;
    color: #00ffd5; /* Ice blue for title */
    margin-bottom: 10px; /* Add spacing under the title for readability */
}

#referralLinkContainer, #referralStats {
    margin-top: 0;
}

#statusMessage {
    color: red; /* Highlight error/status messages */
}

p {
    font-size: 11px;
    margin: 0; /* Consistent text spacing */
}

a {
    color: #00FFFF; /* Bright ice blue links */
    text-decoration: none; /* Clean look for links */
}

a:hover {
    color: #00cccc; /* Slightly darker blue for hover effect */
}

        
      
/* Burner Button */
#burnerUI button {
    background:rgba(0, 0, 0, 0.5);
    border: none;
    padding: 10px 20px;
    font-size: 12px;
    color: #00ffd5;
    font-weight: bold;
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0px 2px 2px rgba(0, 255, 213, 0.2);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    
}

#burnerUI button:hover {
    transform: scale(1.05);
    box-shadow: 0px 6px 10px rgba(0, 255, 213, 0.2);
}

#burnStatus {
    font-size: 8px;
    color: #00FF00;
    margin-top: 10px;
    text-align: center;
}

/* Boost Container */
#boostContainer {
    display: none; /* Hidden until activated */
    text-align: center;
    padding: 20px;
    background: #000;
    border-radius: 12px;
    margin-top: 20px;
    box-shadow: 0px 2px 2px rgba(0, 255, 213, 0.2);
    width: 300px;
}

/* Countdown Timer */
#countdownTimer {
    font-size: 12px;
    color: #00ffd5;
    font-family: 'Courier New', Courier, monospace;
    margin-top: 5px;
    animation: glow 1s infinite alternate;
}

/* Glow Animation */
@keyframes glow {
    0% {
        text-shadow: 0px 0px 5px rgba(0, 255, 255, 0.5), 0px 0px 10px rgba(255, 0, 255, 0.8);
    }
    100% {
        text-shadow: 0px 0px 10px rgba(0, 255, 255, 1), 0px 0px 20px rgba(255, 0, 255, 1);
    }

 } 
/* Style for the button */
#aboutButton {
  background-color: rgba(0, 0, 0, 0.8); /* Slightly transparent black background */
  color: #00ffd5; /* Neon ice blue text */
  border: 0 solid #00A085; /* No visible border */
  border-radius: 8px; /* Rounded corners */
  padding: 10px 15px; /* Button padding for consistent sizing */
  font-size: 13px; /* Readable text size */
  font-family: 'Courier New', monospace; /* Retro tech font style */
  cursor: url('/cursor/faakdis.cur'), auto; /* Custom cursor */
  transition: all 0.3s ease; /* Smooth transitions */
  box-shadow: 0 0 2px #00A085; /* Subtle glow effect */
  text-shadow: 1px 1px 2px #00A085; /* Glowing text effect */
  display: inline-block; /* Inline block for better layout control */
  text-align: center; /* Center-align the button text */
}

#aboutButton:hover {
  background-color: rgba(0, 0, 0, 1); /* Fully opaque background on hover */
  box-shadow: 0 0 4px #00ffd5; /* More intense glow on hover */
  transform: scale(1.05); /* Slight zoom effect on hover */
}

#aboutButton::after {
  content: ''; /* Placeholder for future icons or effects */
  margin-left: 5px; /* Spacing for additional content */
  vertical-align: middle; /* Align with text */
}

#aboutButton:hover::after {
  color: #FF0000; /* Red glow or emphasis (future feature) */
}

/* Style for the popup */
#aboutPopup {
  display: none; /* Hidden by default */
  position: fixed; /* Fixed to viewport */
  top: 50%; /* Center vertically */
  left: 50%; /* Center horizontally */
  transform: translate(-50%, -50%); /* Perfect centering */
  background: rgba(0, 0, 0, 0.9); /* Dark, slightly transparent background */
  padding: 20px; /* Inner spacing for content */
  border-radius: 8px; /* Smooth edges */
  box-shadow: 0 0 7px #00ffd5; /* Neon glow effect */
  color: #00ffd5; /* Neon text */
  z-index: 1000; /* Ensures popup stays on top */
  width: 90%; /* Responsive width */
  max-width: 400px; /* Maximum width */
  text-align: center; /* Center-align content */
}

#aboutPopup.active {
  display: block; /* Show when active */
  animation: fadeIn 0.3s ease-out; /* Smooth fade-in animation */
}

/* Style for the close button inside the popup */
#closePopupButton {
  position: absolute; /* Positioned relative to the popup */
  top: 10px; /* Distance from the top of the popup */
  right: 10px; /* Distance from the right of the popup */
  background-color: rgba(0, 0, 0, 0.8); /* Slightly transparent black background */
  color: #FF0000; /* Bright red for visibility */
  border: 0 solid #00ffd5; /* No visible border */
  border-radius: 50%; /* Circular button */
  width: 10px; /* Size of the button */
  height: 10px; /* Size of the button */
  font-size: 8px; /* Font size for the 'X' */
  font-family: 'Courier New', monospace; /* Matching the theme */
  line-height: 5px; /* Center the 'X' vertically */
  text-align: center; /* Center the 'X' horizontally */
  cursor: url('/cursor/faakdis.cur'), auto; /* Custom cursor */
  box-shadow: 0 0 2px #FF0000; /* Subtle red glow */
  transition: all 0.3s ease; /* Smooth transitions for hover effects */
}

#closePopupButton:hover {
  background-color: #FF0000; /* Bright red on hover */
  color: #000000; /* Black 'X' for contrast */
  box-shadow: 0 0 5px #FF0000; /* Intense glow on hover */
  transform: scale(1.1); /* Slight zoom effect on hover */
}

#closePopupButton:active {
  transform: scale(0.95); /* Slight press-in effect when clicked */
}


/* Fade-in animation */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translate(-50%, -60%); /* Slightly above the center */
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%); /* Fully centered */
  }
}

    </style>
</head>
<body>
     <header style="text-align: center; margin-bottom: 0px; color: #00ffd5;">
        <h1 style="font-size: 35px;"></h1>
        <audio id="popupAudio" src="https://faakdis.com/MUSIC/DONTPANIC.mp3" preload="auto"></audio>
       <button id="aboutButton">WΔT DΔ FΔΔK ?</button>

<div id="aboutPopup">
  
  <h1>FAAKDIS.com is a boundary-pushing platform that fuses blockchain technology, creativity, and gamified engagement. Powered by P o F (Proof of FAAK mining), this experiment challenges traditional ideas of value, ownership, and participation. Here, every action—whether mining, burning, or minting—is part of a bigger story, with your contributions captured as a P o F Receipt, either minted on-chain or saved via IPFS.</h1>

<h1>This isn’t a tool. It’s an experience.</h1> 
  
  <ul>
    <li>Mine: Generate assets through P o F, creating something from nothing.</li>
    <li>Burn: Embrace impermanence by letting go of your creations.</li>
    <li>Mint: Preserve your contributions as a P o F Receipt, a snapshot of your engagement.</li>
    
    
    <h1>This Experiment turns blockchain mechanics into an artistic process. By mining, burning, and minting, participants explore new ways to interact with digital space, questioning ideas like:</h1>

<li>Creation and loss: Is the act of making something as valuable as the product itself?</li>
<li>Value and permanence: Does something need to last forever to matter?</li>
<li>Digital expression: Can blockchain tools be a canvas for creativity?</li>
<h1>Every participant brings their own meaning, making FAAKDIS.com an evolving project shaped by its users.</h1>

<h1>____________________________</h1>
    <h1>SΞPOL!Δ TΞSTNΞT</h1>
    <h1>WORK !N PROGRΞSS</h1>
    
    <h1>REWARD CA: 0xF7b0A6e9f505bE1715566F5e67B5D983F6C3340b</h1>
    <h1>$FKDST: 0xA0aC1A4cA81c141527805500e29d0DaD9e3D4aaC</h1>
  </ul>
  <button id="closePopupButton"></button>
</div> 

     <button id="connectButton" class="button" onclick="connectWallet()">CONNΞCT WΔLLΞT</button>
    <div id="walletAddress" style="margin-top: 10px; color: #00FFFF;"></div>
    <div id="statusMessage" class="status-message"></div>
    </header>
    
    <div class="pof-container">
    <div class="pof-dashboard">
        <h1>P o F</h1>
        <button id="startButton" class="button" onclick="startMining()" style="display: none;">STΔRT M!N!NG</button>
        <button id="stopButton" class="button" onclick="stopMining()" style="display: none;">STOP M!N!NG</button>
    </div>

   
  

    <div class="canvas-container">
    <canvas id="minedCanvas"></canvas>
    <div class="level-bar">
    <div id="levelFill" class="level-fill" style="width: 0%;"></div>
   </div> 
    </div>
  
  
  
    <div class="mining-stats-container">
    <div class="mining-stats"> 
    <div id="hashRate">HΔSH RΔTΞ: 0 H/s & FΔΔK RΔTΞ: 0 H/s</div>
    <div id="minedImages">!MΔGΞS M!NΞD: 0</div>
    <div id="miningReward">M!N!NG TIME: 0</div>
    <div id="dateTime">DATΞ & TIMΞ: --</div> <!-- New element for real-time date and time -->
    <div class="token-balance" id="tokenBalance">TOKΞN BΔLΔNCΞ: 0 $FKDST</div>
    <div id="totalBoostUsed">BOOSTΞD: 0</div>
    
    
    
    <div id="starRating" class="star-rating"></div> <!-- Star rating added here -->
    <canvas id="rateChart" width="400" height="150"></canvas>
    </div> 
</div>


    
     <!-- Burner UI (before boost) -->
<div id="burnerUI">
    <button onclick="burnTokensForBoost()">BURN 1 $FKDST TO BOOST</button>
    <p id="burnStatus"></p>
</div>

<!-- Boost Container (after burning tokens) -->
<div id="boostContainer" style="display: none;">
    <p id="countdownTimer"></p>
</div>
   
   <div class="ipfs-toggle">
    <label>
        <input type="checkbox" id="ipfsToggle" onclick="toggleIPFSViewer(this.checked)">
    </label>


    
     </div> 
   <div id="ipfsImageViewer"> 
   <button id="uploadToIPFSButton" class="button" onclick="uploadReceiptToIPFS()">GΞNΞRΔTE P o F RΞCΞ!PT</button>
    <h4 style="color: #00ffd5;"></h4>
    <div id="ipfsImages" class="gallery-container"></div>
</div>
 
 
 
<!-- Status message for feedback -->
<div id="statusMessage" style="margin-top: 12px; text-align: center;"></div>

<div class="container">
        <h1></h1>
        
        <!-- Referral Link and Stats -->
        <div id="referralLinkContainer" style="display: none;">
            <h3>YOUR RΞFΞRRΔL L!NK:</h3>
            <p id="referralLink"></p>
        </div>
        
        <div id="referralStats">
            <h3>RΞFΞRRΔL STΔTS</h3>
            <p>TOTΔL RΞFΞRRΔLS: <span id="totalReferrals">0</span></p>
            <p>RΞFΞRRΔL RΞWΔRDS: <span id="referralRewards">0</span> $FKDST</p>
        </div>
    </div>
        
     <div class="cta-buttons">        
    
    <a href="https://faakdis.com/HOWTOGETIT">N/Δ</a>
</div>
    
 <audio id="audioPlayer" preload="auto">
    <source src="https://faakdis.com/MUSIC/GONE.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
</audio>
<script src="javascript.js"></script>

<script>
     const fkdsTokenABI = [
    {
        "constant": true,
        "inputs": [{"name": "owner", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"name": "balance", "type": "uint256"}],
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [{"name": "recipient", "type": "address"}, {"name": "amount", "type": "uint256"}],
        "name": "transfer",
        "outputs": [{"name": "", "type": "bool"}],
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [{"name": "spender", "type": "address"}, {"name": "amount", "type": "uint256"}],
        "name": "approve",
        "outputs": [{"name": "", "type": "bool"}],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [{"name": "owner", "type": "address"}, {"name": "spender", "type": "address"}],
        "name": "allowance",
        "outputs": [{"name": "", "type": "uint256"}],
        "type": "function"
    }
];

   const gameRewardABI = [
    {
        "constant": false,
        "inputs": [{"name": "player", "type": "address"}],
        "name": "distributeReward",
        "outputs": [],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [{"name": "player", "type": "address"}],
        "name": "rewards",
        "outputs": [{"name": "", "type": "uint256"}],
        "type": "function"
    }
];


    const nftContractABI = [
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "to",
                    "type": "address"
                },
                {
                    "internalType": "string",
                    "name": "metadataURI",
                    "type": "string"
                }
            ],
            "name": "mintReceiptNFT",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "from",
                    "type": "address"
                },
                {
                    "internalType": "address",
                    "name": "to",
                    "type": "address"
                },
                {
                    "internalType": "uint256",
                    "name": "tokenId",
                    "type": "uint256"
                }
            ],
            "name": "transferFrom",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "constant": true,
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "tokenId",
                    "type": "uint256"
                }
            ],
            "name": "tokenURI",
            "outputs": [
                {
                    "internalType": "string",
                    "name": "",
                    "type": "string"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        }
    ];




   const tokenAddress = "0xA0aC1A4cA81c141527805500e29d0DaD9e3D4aaC";
const gameRewardAddress = "0xF7b0A6e9f505bE1715566F5e67B5D983F6C3340b";
const nftContractAddress = "0x9312CA083A07973762390e02A2Ee6C435aE09bc9"; 
const referralRewards = 1; 

let lastMiningTime = {};
let miningInterval;
let miningActive = false;
let imagesMined = 0;
let miningReward = 0;
let miningSpeed = 250;
const claimThreshold = 400; // Claim every 400 images mined

const canvas = document.getElementById('minedCanvas');
const ctx = canvas.getContext('2d');
canvas.width = 400;
canvas.height = 200;

let web3;
let fkdsContract;
let gameRewardContract;
let userAddress = null;

const displayStatusMessage = (message, isError = true) => {
    const statusMessageElement = document.getElementById('statusMessage');
    statusMessageElement.innerText = message;
    statusMessageElement.style.color = isError ? '#FF0000' : '#00FF00';
};

const updateMiningStats = () => {
    document.getElementById('hashRate').innerText = `HΔSH RΔTΞ: ${Math.random().toFixed(2)} H/s & FΔΔK RΔTΞ: ${Math.random().toFixed(2)} H/s`;
    document.getElementById('minedImages').innerText = `!MΔGΞS M!NΞD: ${imagesMined}`;
    document.getElementById('miningReward').innerText = `M!N!NG T!MΞ: ${miningReward.toFixed(2)} `;
};

const startMining = () => {
    if (!miningActive) {
        miningActive = true;

        document.getElementById('startButton').style.display = 'none';
        document.getElementById('stopButton').style.display = 'inline';

        miningInterval = setInterval(() => {
            imagesMined++;
            miningReward += 0.00238;

            // Display image on canvas
            const img = new Image();
            img.src = 'https://faakdis.com/image/PoF2.png';
            img.onload = () => {
                ctx.drawImage(img, Math.random() * (canvas.width - 15), Math.random() * (canvas.height - 15), 15, 15);
                document.getElementById('levelFill').style.width = `${(imagesMined % 100)}%`;
            };

            // Update displayed stats
            updateMiningStats();

            // Automatically claim rewards at every multiple of 400 images mined
            if (imagesMined % claimThreshold === 0) {
                claimTokens(); // Auto-claim
            }
        }, miningSpeed);
    }
};

const stopMining = () => {
    miningActive = false;
    clearInterval(miningInterval);
    document.getElementById('stopButton').style.display = 'none';
    document.getElementById('startButton').style.display = 'inline';
    document.getElementById('downloadBtn').style.display = 'inline';
};

const claimTokens = async () => {
    if (web3 && gameRewardContract && userAddress) {
        try {
            await gameRewardContract.methods.distributeReward(userAddress).send({ from: userAddress });
            alert('Rewards claimed successfully!');
            displayStatusMessage('Rewards claimed successfully!', false);
            displayTokenBalance();
        } catch (error) {
            console.error("Error claiming rewards:", error);
            displayStatusMessage('Error claiming rewards: ' + error.message, true);
        }
    } else {
        displayStatusMessage('Unable to claim rewards. Contract not initialized.', true);
    }
};

const connectWallet = async () => {
    if (window.ethereum) {
        try {
            await window.ethereum.request({ method: 'eth_requestAccounts' });
            web3 = new Web3(window.ethereum);
            const accounts = await web3.eth.getAccounts();
            userAddress = accounts[0];
            document.getElementById('walletAddress').innerText = ` ${userAddress}`;
            displayStatusMessage('Wallet connected successfully!', false);

            // Hide the connect button after wallet is connected
            document.getElementById('connectButton').style.display = 'none';

            // Initialize contracts
            fkdsContract = new web3.eth.Contract(fkdsTokenABI, tokenAddress);
            gameRewardContract = new web3.eth.Contract(gameRewardABI, gameRewardAddress);

            displayTokenBalance();
            // Display the referral link
            displayReferralLink();

            // Check for referral
            checkForReferral();
            
        } catch (error) {
            console.error("Error connecting wallet:", error);
            displayStatusMessage('Error connecting wallet: ' + error.message);
        }
    } else {
        displayStatusMessage('Please install MetaMask!', true);
    }
};

     const displayReferralLink = () => {
            const referralLink = `${window.location.origin}?ref=${userAddress}`;
            const referralLinkElement = document.getElementById('referralLink');
            const referralContainer = document.getElementById('referralLinkContainer');
            
            referralLinkElement.innerText = referralLink;
            referralContainer.style.display = 'block';
        };

        const checkForReferral = async () => {
            const urlParams = new URLSearchParams(window.location.search);
            const referrerAddress = urlParams.get('ref');
            if (referrerAddress && referrerAddress !== userAddress) {
                await trackReferral(referrerAddress);
            }
        };

        const trackReferral = async (referrerAddress) => {
            try {
                let referralCount = parseInt(localStorage.getItem(`${referrerAddress}_referrals`) || "0", 10);
                referralCount += 1;
                localStorage.setItem(`${referrerAddress}_referrals`, referralCount);

                const rewardAmount = web3.utils.toWei(referralRewards.toString(), 'ether');
                // Distribute reward via game reward contract
                await gameRewardContract.methods.distributeReward(referrerAddress).send({ from: userAddress });

                displayStatusMessage(`Referral recorded! Sent ${referralRewards} $FKDST to ${gameRewardAddress}`, false);
            } catch (error) {
                console.error("Error rewarding referrer:", error);
                displayStatusMessage("Referral tracking failed.");
            }
        };

        const updateReferralStats = () => {
            const referralCount = parseInt(localStorage.getItem(`${userAddress}_referrals`) || "0", 10);
            const earnedTokens = referralCount * referralRewards;
            document.getElementById('totalReferrals').innerText = referralCount;
            document.getElementById('referralRewards').innerText = earnedTokens;
        };
        
     const updateDateTime = () => {
        const dateTimeElement = document.getElementById('dateTime');
        const now = new Date();

        // Format date and time as "YYYY-MM-DD HH:MM:SS"
        const formattedDateTime = now.toLocaleString('en-US', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false  // 24-hour format
        });
        // Set the formatted date and time in the element
        dateTimeElement.innerText = `DATΞ & TIMΞ: ${formattedDateTime}`;
    };
    // Start real-time clock updates
    setInterval(updateDateTime, 1000);
    
    const displayTokenBalance = async () => {
    if (fkdsContract && userAddress) {
        try {
            const balance = await fkdsContract.methods.balanceOf(userAddress).call();
            const formattedBalance = web3.utils.fromWei(balance, 'ether');
            document.getElementById('tokenBalance').innerText = `TOKΞN BΔLΔNCΞ: ${formattedBalance} $FKDST`;
            displayStatusMessage('Token balance updated!', false);
            
            // Update star rating based on token balance
            updateStarRating(parseFloat(formattedBalance));
        } catch (error) {
            console.error("Error fetching token balance:", error);
            displayStatusMessage('Error fetching token balance: ' + error.message);
        }
    } else {
        displayStatusMessage('Unable to fetch balance. Contract not initialized.', true);
    }
};
const updateStarRating = (balance) => {
    const starRatingElement = document.getElementById('starRating');
    let stars = 0;

    if (balance >= 50000) stars = 5;
    else if (balance > 1000) stars = 4;
    else if (balance >= 500) stars = 3;
    else if (balance >= 50) stars = 2;
    else if (balance > 5) stars = 1;
    else if (balance > 0) stars = 0;
    
    starRatingElement.innerHTML = '★'.repeat(stars) + '☆'.repeat(5 - stars);

        
        document.getElementById('startButton').style.display = 'inline';
    };

    window.addEventListener('load', () => {
        if (window.ethereum) {
            web3 = new Web3(window.ethereum);
        } else {
            console.log('Non-Ethereum browser detected. You should consider trying MetaMask!');
            displayStatusMessage('Non-Ethereum browser detected. Please try MetaMask.');
        }
        
        });  
        
        const rateChartContext = document.getElementById('rateChart').getContext('2d');
let hashData = [];
let faakData = [];
let labels = [];

const rateChart = new Chart(rateChartContext, {
    type: 'line',
    data: {
        labels: labels,
        datasets: [
            {
                label: 'Hash Rate',
                borderColor: '#ff5e00',
                data: hashData,
                fill: false,
            },
            {
                label: 'FAAK Rate',
                borderColor: '#00ffd5',
                data: faakData,
                fill: false,
            },
        ]
    },
    options: {
        scales: {
            x: {
                display: true,
                title: { display: true, text: 'Time' }
            },
            y: {
                display: true,
                title: { display: true, text: 'Rate (H/s)' }
            }
        }
    }
});

function updateRateChart() {
    const hashRate = Math.random().toFixed(2);
    const faakRate = Math.random().toFixed(2);
    
    // Limit data points for visual clarity
    if (hashData.length > 20) {
        hashData.shift();
        faakData.shift();
        labels.shift();
    }
    
    hashData.push(hashRate);
    faakData.push(faakRate);
    labels.push(new Date().toLocaleTimeString());
    
    rateChart.update();

    document.getElementById('hashRate').innerText = `HΔSH RΔTΞ: ${hashRate} H/s & FΔΔK RΔTΞ: ${faakRate} H/s`;
}

// Set normal mining speed and boost multiplier
let normalMiningSpeed = 1; // Normal mining speed (hash/sec)
let boostMultiplier = 2; // Boost multiplier
let currentMiningSpeed = normalMiningSpeed; // Track current mining speed
let boostActive = false; // Track if boost is active
let boostEndTime = 0; // Timestamp when boost ends
let burnAmount = 1; // Amount of $FKDST to burn for boost
let boostContainer = document.getElementById('boostContainer'); // Boost container element
let countdownTimer = document.getElementById('countdownTimer'); // Countdown display element
let totalBoostUsed = 0; // Total amount of $FKDST used for boosts

// Function to start the burn transaction and apply the boost
async function burnTokensForBoost() {
    const burnAmountWei = web3.utils.toWei(burnAmount.toString(), 'ether');

    try {
        // Transfer the burn amount to the dead address
        const burnTransaction = await fkdsContract.methods
            .transfer('0x000000000000000000000000000000000000dEaD', burnAmountWei)
            .send({ from: userAddress });

        document.getElementById('burnStatus').innerText = `Burn successful! TX: ${burnTransaction.transactionHash}`;

        // Update total boost used
        totalBoostUsed += burnAmount;
        document.getElementById('totalBoostUsed').innerText = `BOOSTΞD: ${totalBoostUsed} `;

        // Start boost if burn is successful
        activateBoost();
    } catch (error) {
        console.error("Burn failed:", error);
        document.getElementById('burnStatus').innerText = "Failed to burn tokens. See console for details.";
    }
}

// Activate boost: Increase mining speed and start 5-minute timer
function activateBoost() {
    if (boostActive) return; // Prevent duplicate activation

    boostActive = true;
    boostEndTime = Date.now() + 5 * 60 * 1000; // 5 minutes from now
    currentMiningSpeed = normalMiningSpeed * boostMultiplier; // Apply boost multiplier

    // Hide burner UI and show boost container with countdown
    document.getElementById('burnerUI').style.display = 'none';
    boostContainer.style.display = 'block';

    // Update stats and UI
    updateBoostCountdown();
    updateRateChart(); // Reflect speed changes in the rate chart

    // Set interval to manage boost countdown and deactivation
    const countdownInterval = setInterval(() => {
        if (Date.now() >= boostEndTime) {
            clearInterval(countdownInterval); // Stop countdown when boost ends
            deactivateBoost();
        } else {
            updateBoostCountdown();
        }
    }, 1000);
}

// Update countdown timer display
function updateBoostCountdown() {
    const timeLeft = boostEndTime - Date.now();
    if (timeLeft > 0) {
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        countdownTimer.innerText = `Boost active: ${minutes}m ${seconds}s remaining`;
    }
}

// Deactivate boost: Reset mining speed and UI elements
function deactivateBoost() {
    boostActive = false;
    currentMiningSpeed = normalMiningSpeed; // Reset to normal speed
    boostContainer.style.display = 'none';
    document.getElementById('burnerUI').style.display = 'block';
    document.getElementById('statusMessage').textContent = "Boost has ended. Mining speed returned to normal.";
    updateRateChart(); // Reflect speed reset in the rate chart
}

// Update mining speed in the rate chart dynamically
function updateRateChart() {
    const hashRate = (currentMiningSpeed * Math.random()).toFixed(2);
    const faakRate = (currentMiningSpeed * Math.random()).toFixed(2);

    // Maintain chart data limits for clarity
    if (hashData.length > 20) {
        hashData.shift();
        faakData.shift();
        labels.shift();
    }

    hashData.push(hashRate);
    faakData.push(faakRate);
    labels.push(new Date().toLocaleTimeString());

    rateChart.update();

    // Update hash and faak rates in the UI
    document.getElementById('hashRate').innerText = `HΔSH RΔTΞ: ${hashRate} H/s & FΔΔK RΔTΞ: ${faakRate} H/s`;
}

// Start real-time updates for the rate chart
setInterval(updateRateChart, 1000);

// Initialize UI stats on page load
window.addEventListener('load', () => {
    updateRateChart(); // Start with normal speed
    document.getElementById('hashRate').textContent = `HΔSH RΔTΞ: ${normalMiningSpeed} H/s`;
});


    // Hide boost UI and show burner UI
    boostContainer.style.display = 'none';
    document.getElementById('burnerUI').style.display = 'block';
}

document.getElementById('aboutButton').addEventListener('click', function() {
  document.getElementById('aboutPopup').style.display = 'block';
});

document.getElementById('closePopupButton').addEventListener('click', function() {
  document.getElementById('aboutPopup').style.display = 'none';
});

document.getElementById('aboutButton').addEventListener('click', function() {
  document.getElementById('aboutPopup').style.display = 'block';
  playAudio();
});

document.getElementById('closePopupButton').addEventListener('click', function() {
  document.getElementById('aboutPopup').style.display = 'none';
  stopAudio();
});



function openPopup() {
  document.querySelector('.about-popup').classList.remove('hidden');
}

function closePopup() {
  document.querySelector('.about-popup').classList.add('hidden');
}

function playAudio() {
  var audio = document.getElementById('popupAudio');
  audio.play().catch(error => {
    // For browsers that require user interaction for autoplay
    console.log("Audio play prevented due to user interaction requirement.");
  });
}




 // Pinata API credentials
const pinataApiKey = 'd68de55cf26c7c309b1a';
const pinataSecretApiKey = 'c1eb059a07b47e0edcacab633bd23aaa231e7d79008810e88125ff03a6ca8a1e';

// Array to store uploaded IPFS URLs securely
let ipfsImageURLs = JSON.parse(localStorage.getItem('ipfsImageURLs') || '[]');

// Sanitize URL input
const sanitizeURL = (url) => {
    const urlPattern = /^https:\/\/ipfs\.io\/ipfs\/[A-Za-z0-9]+$/;
    return urlPattern.test(url) ? url : '';
};

// Extract IPFS hash from the URL
const extractIpfsHash = (url) => {
    const match = url.match(/\/ipfs\/([A-Za-z0-9]+)/);
    return match ? match[1] : null;
};

// Generate the receipt image and return it as a data URL
const getReceiptImageURL = () => {
    const receiptCanvas = document.createElement('canvas');
    const receiptCtx = receiptCanvas.getContext('2d');
    receiptCanvas.width = 400;
    receiptCanvas.height = 580;

    const now = new Date();
    const formattedDateTime = now.toLocaleString('en-US', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
    });

    // Set up canvas background and header
    receiptCtx.fillStyle = "#FFFFFFFC";
    receiptCtx.fillRect(0, 0, receiptCanvas.width, receiptCanvas.height);
    receiptCtx.fillStyle = "#000000";
    receiptCtx.font = "bold 15px Arial";
    receiptCtx.textAlign = "center";
    receiptCtx.fillText("P o F RΞCΞ!PT", receiptCanvas.width / 2, 40);

    // Display Date and Time
    receiptCtx.font = "12px Arial";
    receiptCtx.textAlign = "left";
    receiptCtx.fillText(`: ${formattedDateTime}`, 20, 70);

    // Add mining stats on the receipt
    const stats = [
        { label: "", value: document.getElementById('hashRate').innerText },
        { label: "", value: document.getElementById('minedImages').innerText },
        { label: "", value: document.getElementById('miningReward').innerText },
        { label: "", value: document.getElementById('totalBoostUsed').innerText },
        { label: "", value: document.getElementById('tokenBalance').innerText },
        { label: "", value: document.getElementById('walletAddress').innerText },
        { label: "", value: document.getElementById('starRating').innerText }
    ];

    let startY = 100;
    stats.forEach((stat, index) => {
        receiptCtx.fillText(`${stat.label}: ${stat.value}`, 20, startY + (index * 30));
    });

    // Draw mined images on the receipt
    const minedCanvas = document.getElementById('minedCanvas');
    if (minedCanvas) {
        receiptCtx.drawImage(minedCanvas, 20, startY + stats.length * 30 + 30, 360, 180);
    }

    receiptCtx.font = "italic 12px Arial";
    receiptCtx.textAlign = "center";
    receiptCtx.fillText("🜨 ♁ ☷ 🜃", receiptCanvas.width / 2, receiptCanvas.height - 40);

    return receiptCanvas.toDataURL('image/png');
};

// Convert a data URL to a blob for uploading to IPFS
const dataURLToBlob = async (dataURL) => {
    try {
        const response = await fetch(dataURL);
        return await response.blob();
    } catch (error) {
        console.error("Error converting data URL to blob:", error);
    }
};

// Upload receipt to IPFS
const uploadToIPFS = async (blob) => {
    try {
        const formData = new FormData();
        formData.append('file', blob);

        const response = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
            method: 'POST',
            headers: {
                'pinata_api_key': pinataApiKey,
                'pinata_secret_api_key': pinataSecretApiKey
            },
            body: formData
        });

        if (!response.ok) {
            throw new Error("Failed to upload to IPFS");
        }

        const data = await response.json();
        const ipfsURL = `https://ipfs.io/ipfs/${data.IpfsHash}`;
        return sanitizeURL(ipfsURL);
    } catch (error) {
        console.error("IPFS upload error:", error);
        alert("Failed to upload to IPFS. Please try again later.");
    }
};

// Unpin from IPFS using Pinata's API
const unpinFromIPFS = async (ipfsHash) => {
    try {
        const response = await fetch(`https://api.pinata.cloud/pinning/unpin/${ipfsHash}`, {
            method: 'DELETE',
            headers: {
                'pinata_api_key': pinataApiKey,
                'pinata_secret_api_key': pinataSecretApiKey
            }
        });

        if (!response.ok) {
            throw new Error(`Failed to unpin from IPFS. Status: ${response.status}`);
        }

        console.log("Successfully unpinned from IPFS:", ipfsHash);
    } catch (error) {
        console.error("IPFS unpin error:", error);
        alert("Failed to unpin from IPFS. Please try again later.");
    }
};

// Upload receipt, add to gallery, and store in local storage
const uploadReceiptToIPFS = async () => {
    const imageDataURL = getReceiptImageURL();
    const blob = await dataURLToBlob(imageDataURL);

    if (!blob) {
        console.error("Failed to create Blob from image data");
        return;
    }

    const ipfsURL = await uploadToIPFS(blob);
    if (ipfsURL) {
        ipfsImageURLs.push(ipfsURL);
        localStorage.setItem('ipfsImageURLs', JSON.stringify(ipfsImageURLs));
        displayIPFSImage(ipfsURL);
    }
};

// Function to move between images
let currentSlide = 0;

function moveSlide(direction) {
    const images = document.querySelectorAll('.image-box');
    const totalImages = images.length;

    currentSlide += direction;

    if (currentSlide < 0) currentSlide = totalImages - 1;
    else if (currentSlide >= totalImages) currentSlide = 0;

    const galleryContainer = document.querySelector('.gallery-container');
    const offset = -currentSlide * 100;
    galleryContainer.style.transform = `translateX(${offset}%)`;
}

// Function to share receipt on Twitter with referral link from an HTML element
const shareOnTwitter = (url) => {
    const encodedURL = encodeURIComponent(url);
    const tweetText = encodeURIComponent("Check out my P o F RΞCΞ!PT:");

    // Retrieve referral link from the HTML element
    const referralLinkElement = document.getElementById('referralLink');
    const referralLink = referralLinkElement ? referralLinkElement.textContent.trim() : null;

    // Construct the Twitter share URL
    let twitterShareURL = `https://twitter.com/intent/tweet?text=${tweetText}&url=${encodedURL}`;

    if (referralLink) {
        const encodedReferralLink = encodeURIComponent(`\n\nReferral Link: ${referralLink}`);
        twitterShareURL += `url=${encodedReferralLink}`;
    }

    // Open the Twitter share URL in a new tab
    window.open(twitterShareURL, '_blank');
};
// Function to keep (remove from viewer but not delete) the image
const keepImage = (element) => {
    element.style.display = "none"; // Hides the image from the viewer
    displayStatusMessage("Receipt removed from viewer but kept in local storage.", false);
};

const burnImage = (url, element) => {
    if (!url || !element) {
        console.error("Invalid URL or element");
        return;
    }

    try {
        // Update localStorage
        ipfsImageURLs = ipfsImageURLs.filter((storedURL) => storedURL !== url);
        localStorage.setItem('ipfsImageURLs', JSON.stringify(ipfsImageURLs));

        // Remove from DOM
        element.remove();

        // Unpin from IPFS (optional)
        const ipfsHash = url.split('/').pop(); // Extract IPFS hash from URL
        unpinFromIPFS(ipfsHash);

        displayStatusMessage("P o F successfully burned.", true);
    } catch (error) {
        console.error("Error burning the image:", error);
        displayStatusMessage("Failed to burn the image. Try again.", false);
    }
};



// Display IPFS receipt in the gallery
const displayIPFSImage = (url) => {
    const sanitizedURL = sanitizeURL(url);
    if (!sanitizedURL) return;

    const ipfsImagesContainer = document.getElementById('ipfsImages');
    const imageWrapper = document.createElement('div');
    imageWrapper.className = 'image-box';

    const img = document.createElement('img');
    img.src = sanitizedURL;
    img.alt = "Uploaded Receipt";
    img.style.width = "200px"; // Thumbnail size
    imageWrapper.appendChild(img);

    // Burn button
    const burnButton = document.createElement('button');
    burnButton.className = 'burn-btn button';
    burnButton.innerText = "BURN";
    burnButton.onclick = () => burnImage(url, imageWrapper);
    imageWrapper.appendChild(burnButton);
    
    // Keep button
    const keepButton = document.createElement('button');
    keepButton.className = 'keep-btn button';
    keepButton.innerText = "KΞΞP";
    keepButton.onclick = () => keepImage(imageWrapper);
    imageWrapper.appendChild(keepButton);

    ipfsImagesContainer.appendChild(imageWrapper);

    // Mint NFT button
    const mintButton = document.createElement('button');
    mintButton.className = 'mint-btn button';
    mintButton.innerText = "MIN!T";
    mintButton.onclick = async () => {
        try {
            const blob = await fetch(sanitizedURL).then(res => res.blob());
            const ipfsURL = await uploadToIPFS(blob);
            const metadata = {
                name: "Receipt NFT",
                description: "A digital receipt stored on IPFS",
                image: ipfsURL,
                attributes: [{ trait_type: "Type", value: "Receipt" }]
            };

            const metadataResponse = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'pinata_api_key': pinataApiKey,
                    'pinata_secret_api_key': pinataSecretApiKey
                },
                body: JSON.stringify(metadata)
            });

            if (!metadataResponse.ok) throw new Error('Failed to upload metadata to IPFS');
            const metadataData = await metadataResponse.json();
            const metadataURL = `ipfs://${metadataData.IpfsHash}`;

            alert('Minted NFT Metadata URL: ' + metadataURL);
        } catch (error) {
            alert('Minting failed: ' + error.message);
        }
    };
    imageWrapper.appendChild(mintButton);

    // Share button
    const shareButton = document.createElement('button');
    shareButton.className = 'share-btn button';
    shareButton.innerText = "SHARΞ";
    shareButton.onclick = () => shareOnTwitter(sanitizedURL);
    imageWrapper.appendChild(shareButton);

   
};

// Load all stored IPFS receipts on page load
const loadAllIPFSImages = () => {
    ipfsImageURLs.forEach((url) => {
        displayIPFSImage(url);
    });
};

window.onload = loadAllIPFSImages;


  // Function to play audio
    function playAudio() {
        var audio = document.getElementById('audioPlayer');
        audio.play();
    }

    // Trigger audio when the connect button is clicked (or any other button you want)
    document.getElementById('connectButton').addEventListener('click', playAudio);

function toggleIPFSViewer(show) {
    const ipfsContainer = document.getElementById('ipfsImageViewer');
    if (ipfsContainer) {
        ipfsContainer.style.display = show ? 'block' : 'none';
    }
}

// Add this to your initialization code within the DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', (event) => {
    // ... other initialization code ...
    const ipfsToggle = document.getElementById('ipfsToggle');
    if (ipfsToggle) {
        ipfsToggle.checked = true;  // Default to showing the IPFS viewer
    }
});

    
  </script>
</body>
</html>
